<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integrated AI-SDN Dashboard</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .animate-spin-slow {
            animation: spin 3s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        /* Custom chart styling */
        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
        }
        canvas {
            display: block;
        }
        /* Toggle switch styling */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #2196F3;
        }
        input:checked + .slider:before {
            transform: translateX(26px);
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center p-4">

    <div class="bg-white rounded-xl shadow-2xl p-6 md:p-10 w-full max-w-5xl transform transition-all duration-500 ease-in-out">
        <h1 class="text-3xl md:text-4xl font-bold text-gray-800 mb-6 text-center">Integrated AI-SDN Dashboard</h1>
        
        <!-- Tab Navigation -->
        <div class="flex border-b border-gray-200 mb-6">
            <button class="tab-button px-4 py-2 text-sm font-semibold text-gray-600 border-b-2 border-transparent hover:text-blue-600 hover:border-blue-600 transition-colors duration-300 active-tab" data-tab="topology">
                Network Topology
            </button>
            <button class="tab-button px-4 py-2 text-sm font-semibold text-gray-600 border-b-2 border-transparent hover:text-blue-600 hover:border-blue-600 transition-colors duration-300" data-tab="dashboard">
                Network Dashboard
            </button>
            <button class="tab-button px-4 py-2 text-sm font-semibold text-gray-600 border-b-2 border-transparent hover:text-blue-600 hover:border-blue-600 transition-colors duration-300" data-tab="allocator">
                Bandwidth Allocator
            </button>
        </div>

        <!-- Tab Contents -->
        <div id="topology" class="tab-content active">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Network Topology</h2>
            <p class="text-gray-500 mb-6 text-center">A visual representation of the network topology with draggable nodes.</p>
            <div class="relative w-full rounded-xl overflow-hidden shadow-inner mb-6">
                <canvas id="networkCanvas" class="w-full h-96 md:h-[600px] bg-gray-50"></canvas>
            </div>
            <div class="text-center">
                <button id="resetButton" class="bg-blue-600 text-white font-semibold py-2 px-6 rounded-full shadow-lg hover:bg-blue-700 transition-colors duration-300 transform hover:scale-105">
                    Reset View
                </button>
            </div>
        </div>

        <div id="dashboard" class="tab-content">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Network Activity Dashboard</h2>
            <p class="text-gray-500 mb-6 text-center">Real-time network performance metrics and policy status (simulated).</p>
            <!-- Status and Loading Indicator -->
            <div id="statusMessage" class="text-center text-sm font-semibold text-gray-700 mb-4">
                <span id="loadingIndicator" class="hidden inline-block animate-spin-slow rounded-full h-4 w-4 border-2 border-t-2 border-blue-500 mr-2"></span>
                <span id="statusText">Fetching data...</span>
            </div>
            <!-- Key Metrics Section -->
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                <div class="bg-blue-50 rounded-lg p-5 shadow-inner">
                    <p class="text-sm font-medium text-blue-600">Bandwidth Utilization</p>
                    <p class="text-2xl font-bold text-gray-800 mt-1"><span id="bandwidth">--</span>%</p>
                </div>
                <div class="bg-green-50 rounded-lg p-5 shadow-inner">
                    <p class="text-sm font-medium text-green-600">Latency</p>
                    <p class="text-2xl font-bold text-gray-800 mt-1"><span id="latency">--</span>ms</p>
                </div>
                <div class="bg-red-50 rounded-lg p-5 shadow-inner">
                    <p class="text-sm font-medium text-red-600">Packet Loss</p>
                    <p class="text-2xl font-bold text-gray-800 mt-1"><span id="packetLoss">--</span>%</p>
                </div>
                <div class="bg-yellow-50 rounded-lg p-5 shadow-inner">
                    <p class="text-sm font-medium text-yellow-600">Current Policy</p>
                    <p class="text-xl font-bold text-gray-800 mt-1" id="currentPolicy">--</p>
                </div>
            </div>
            <!-- Charts Section -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div class="bg-gray-50 rounded-xl p-6 shadow-md">
                    <h3 class="text-xl font-semibold text-gray-800 mb-4 text-center">Bandwidth Over Time</h3>
                    <div class="chart-container">
                        <canvas id="bandwidthChart"></canvas>
                    </div>
                </div>
                <div class="bg-gray-50 rounded-xl p-6 shadow-md">
                    <h3 class="text-xl font-semibold text-gray-800 mb-4 text-center">Latency Over Time</h3>
                    <div class="chart-container">
                        <canvas id="latencyChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div id="allocator" class="tab-content">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Bandwidth Allocator</h2>
            <p class="text-gray-500 mb-6 text-center">
                Set the total available bandwidth and see how it's allocated based on the selected configuration.
            </p>
            <!-- Mode Toggle -->
            <div class="flex items-center justify-center space-x-4 mb-8">
                <span class="text-gray-700 font-semibold">Traditional Mode</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="aiToggle">
                    <span class="slider"></span>
                </label>
                <span class="text-gray-700 font-semibold">AI-Driven Mode</span>
            </div>
            <!-- Input Section -->
            <div class="flex flex-col sm:flex-row items-center justify-center space-y-4 sm:space-y-0 sm:space-x-4 mb-4">
                <label for="totalBandwidth" class="text-gray-700 font-semibold">Total Bandwidth (Mbps):</label>
                <input type="number" id="totalBandwidth" class="w-full sm:w-40 p-3 rounded-lg border-2 border-gray-300 focus:outline-none focus:border-blue-500 transition-colors" placeholder="e.g., 900">
                <button id="calculateBtn" class="w-full sm:w-auto bg-blue-600 text-white font-semibold py-3 px-6 rounded-full shadow-lg hover:bg-blue-700 transition-colors duration-300 transform hover:scale-105">
                    Calculate
                </button>
            </div>
            <div class="text-center mb-8">
                <button id="loadConfigBtn" class="bg-gray-200 text-gray-800 font-semibold py-2 px-6 rounded-full shadow-lg hover:bg-gray-300 transition-colors duration-300 transform hover:scale-105">
                    Load Default Configuration
                </button>
            </div>
            <!-- Allocation Results Section -->
            <h3 class="text-xl font-bold text-gray-800 mb-4 text-center">Allocated Bandwidth per Device</h3>
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                <div class="bg-green-50 rounded-lg p-5 shadow-inner">
                    <p class="text-sm font-medium text-green-600">Server</p>
                    <p class="text-xl font-bold text-gray-800 mt-1"><span id="serverBw">--</span> Mbps</p>
                </div>
                <div class="bg-blue-50 rounded-lg p-5 shadow-inner">
                    <p class="text-sm font-medium text-blue-600">Host 1 (h1)</p>
                    <p class="text-xl font-bold text-gray-800 mt-1"><span id="h1Bw">--</span> Mbps</p>
                </div>
                <div class="bg-yellow-50 rounded-lg p-5 shadow-inner">
                    <p class="text-sm font-medium text-yellow-600">Host 2 (h2)</p>
                    <p class="text-xl font-bold text-gray-800 mt-1"><span id="h2Bw">--</span> Mbps</p>
                </div>
            </div>
            <!-- Explanation Section -->
            <div id="explanation" class="mt-8 text-sm text-gray-600">
                <!-- Explanation text will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <script>
        (function() {
            // --- GLOBAL DOM ELEMENTS & VARIABLES ---
            const canvas = document.getElementById('networkCanvas');
            const ctx = canvas.getContext('2d');
            let nodes = [];
            let links = [];
            let draggingNode = null;
            let offsetX, offsetY;

            // --- TAB MANAGEMENT ---
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');

            function switchTab(tabId) {
                tabButtons.forEach(button => button.classList.remove('active-tab', 'border-blue-600'));
                tabContents.forEach(content => content.classList.remove('active'));

                const activeButton = document.querySelector(`.tab-button[data-tab="${tabId}"]`);
                const activeContent = document.getElementById(tabId);

                if (activeButton && activeContent) {
                    activeButton.classList.add('active-tab', 'border-blue-600');
                    activeContent.classList.add('active');
                }

                if (tabId === 'topology') {
                    const canvas = document.getElementById('networkCanvas');
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;
                    drawTopology();
                } else if (tabId === 'dashboard') {
                    clearInterval(window.dashboardInterval);
                    window.dashboardInterval = setInterval(fetchDashboardData, 5000);
                } else {
                    clearInterval(window.dashboardInterval);
                }
            }

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.getAttribute('data-tab');
                    switchTab(tabId);
                });
            });

            switchTab('topology');


            // --- NETWORK TOPOLOGY LOGIC ---
            const initialNodes = [
                { id: 'h1', type: 'host', x: 200, y: 100 },
                { id: 'h2', type: 'host', x: 200, y: 300 },
                { id: 'server', type: 'server', x: 600, y: 200 },
                { id: 's1', type: 'switch', x: 400, y: 200 }
            ];

            const initialLinks = [
                { from: 'h1', to: 's1', label: '700 Mbps' },
                { from: 'h2', to: 's1' },
                { from: 'server', to: 's1' }
            ];

            function initializeTopology() {
                nodes = JSON.parse(JSON.stringify(initialNodes));
                links = JSON.parse(JSON.stringify(initialLinks));
                drawTopology();
            }

            function drawTopology() {
                if (!ctx) return;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = '#9ca3af';
                ctx.lineWidth = 2;
                links.forEach(link => {
                    const fromNode = nodes.find(n => n.id === link.from);
                    const toNode = nodes.find(n => n.id === link.to);
                    if (fromNode && toNode) {
                        ctx.beginPath();
                        ctx.moveTo(fromNode.x, fromNode.y);
                        ctx.lineTo(toNode.x, toNode.y);
                        ctx.stroke();
                        if (link.label) {
                            ctx.fillStyle = '#1f2937';
                            ctx.font = '12px Inter';
                            const midX = (fromNode.x + toNode.x) / 2;
                            const midY = (fromNode.y + toNode.y) / 2;
                            ctx.fillText(link.label, midX, midY - 5);
                        }
                    }
                });

                nodes.forEach(node => {
                    ctx.beginPath();
                    let color;
                    switch (node.type) {
                        case 'host':
                            color = '#10b981';
                            break;
                        case 'server':
                            color = '#ef4444';
                            break;
                        case 'switch':
                            color = '#3b82f6';
                            break;
                        default:
                            color = '#6b7280';
                    }
                    ctx.fillStyle = color;
                    ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.fillStyle = '#1f2937';
                    ctx.font = '14px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText(node.id, node.x, node.y + 30);
                });
            }

            function getNodeAt(x, y) {
                for (const node of nodes) {
                    const dx = x - node.x;
                    const dy = y - node.y;
                    if (Math.sqrt(dx * dx + dy * dy) < 20) {
                        return node;
                    }
                }
                return null;
            }

            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const node = getNodeAt(x, y);
                if (node) {
                    draggingNode = node;
                    offsetX = x - node.x;
                    offsetY = y - node.y;
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (draggingNode) {
                    const rect = canvas.getBoundingClientRect();
                    draggingNode.x = e.clientX - rect.left - offsetX;
                    draggingNode.y = e.clientY - rect.top - offsetY;
                    drawTopology();
                }
            });

            canvas.addEventListener('mouseup', () => {
                draggingNode = null;
            });
            
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                const node = getNodeAt(x, y);
                if (node) {
                    draggingNode = node;
                    offsetX = x - node.x;
                    offsetY = y - node.y;
                }
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (draggingNode) {
                    const touch = e.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    draggingNode.x = touch.clientX - rect.left - offsetX;
                    draggingNode.y = touch.clientY - rect.top - offsetY;
                    drawTopology();
                }
            });

            canvas.addEventListener('touchend', () => {
                draggingNode = null;
            });

            document.getElementById('resetButton').addEventListener('click', initializeTopology);
            
            // --- NETWORK DASHBOARD LOGIC (MODIFIED TO USE MOCK DATA) ---
            const bandwidthEl = document.getElementById('bandwidth');
            const latencyEl = document.getElementById('latency');
            const packetLossEl = document.getElementById('packetLoss');
            const currentPolicyEl = document.getElementById('currentPolicy');
            const statusTextEl = document.getElementById('statusText');
            const loadingIndicatorEl = document.getElementById('loadingIndicator');

            let bandwidthData = [];
            let latencyData = [];
            const maxDataPoints = 30;

            function drawChart(canvas, data, color) {
                const ctx = canvas.getContext('2d');
                if (!ctx) return;
                const width = canvas.width;
                const height = canvas.height;
                const padding = 20;
                const chartHeight = height - padding * 2;
                const chartWidth = width - padding * 2;
                const maxValue = Math.max(...data, 100);

                ctx.clearRect(0, 0, width, height);
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;

                if (data.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(padding, height - padding - (data[0] / maxValue) * chartHeight);

                    for (let i = 1; i < data.length; i++) {
                        const x = padding + (i / (maxDataPoints - 1)) * chartWidth;
                        const y = height - padding - (data[i] / maxValue) * chartHeight;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    ctx.fillStyle = color;
                    for (let i = 0; i < data.length; i++) {
                        const x = padding + (i / (maxDataPoints - 1)) * chartWidth;
                        const y = height - padding - (data[i] / maxValue) * chartHeight;
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            async function fetchDashboardData() {
                loadingIndicatorEl.classList.remove('hidden');
                statusTextEl.textContent = 'Fetching new data...';

                try {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    const isAIDriven = document.getElementById('aiToggle').checked;
                    const policyText = isAIDriven ? "AI Policy" : "Static Policy";
                    
                    const data = {
                        bandwidth_utilization: Math.floor(Math.random() * 80) + 20,
                        latency: Math.floor(Math.random() * 100) + 10,
                        packet_loss: (Math.random() * 5).toFixed(2),
                        current_qos_policy: policyText
                    };

                    bandwidthEl.textContent = data.bandwidth_utilization;
                    latencyEl.textContent = data.latency;
                    packetLossEl.textContent = data.packet_loss;
                    currentPolicyEl.textContent = data.current_qos_policy;

                    bandwidthData.push(data.bandwidth_utilization);
                    latencyData.push(data.latency);
                    if (bandwidthData.length > maxDataPoints) {
                        bandwidthData.shift();
                        latencyData.shift();
                    }
                    
                    const bandwidthChart = document.getElementById('bandwidthChart');
                    const latencyChart = document.getElementById('latencyChart');
                    if (bandwidthChart && latencyChart) {
                        bandwidthChart.width = bandwidthChart.offsetWidth;
                        bandwidthChart.height = bandwidthChart.offsetHeight;
                        latencyChart.width = latencyChart.offsetWidth;
                        latencyChart.height = latencyChart.offsetHeight;
                        drawChart(bandwidthChart, bandwidthData, '#3b82f6');
                        drawChart(latencyChart, latencyData, '#10b981');
                    }

                    statusTextEl.textContent = 'Data updated successfully (mocked).';
                } catch (error) {
                    console.error('Error fetching data:', error);
                    statusTextEl.textContent = 'Failed to fetch data (using mock data).';
                } finally {
                    loadingIndicatorEl.classList.add('hidden');
                }
            }


            // --- BANDWIDTH ALLOCATOR LOGIC ---
            const totalBandwidthInput = document.getElementById('totalBandwidth');
            const calculateBtn = document.getElementById('calculateBtn');
            const loadConfigBtn = document.getElementById('loadConfigBtn');
            const aiToggle = document.getElementById('aiToggle');
            const explanationDiv = document.getElementById('explanation');
            const serverBwEl = document.getElementById('serverBw');
            const h1BwEl = document.getElementById('h1Bw');
            const h2BwEl = document.getElementById('h2Bw');
            
            const AI_ALLOCATION = { server: 0.60, h1: 0.30, h2: 0.10 };
            const TRADITIONAL_ALLOCATION = 1 / 3;

            function updateExplanation() {
                const isAIDriven = aiToggle.checked;
                let content = '';

                if (isAIDriven) {
                    content = `
                        <p class="font-semibold mb-2">How the calculation works:</p>
                        <p>
                            The AI uses a simple prioritization model to allocate bandwidth based on the total available bandwidth.
                        </p>
                        <ul class="list-disc list-inside mt-2">
                            <li><span class="font-bold">Server:</span> Receives 60% of the total bandwidth for critical services.</li>
                            <li><span class="font-bold">Host 1 (h1):</span> Receives 30% for high-priority user traffic.</li>
                            <li><span class="font-bold">Host 2 (h2):</span> Receives 10% for normal user traffic.</li>
                        </ul>
                    `;
                    loadConfigBtn.textContent = 'Load AI Configuration';
                } else {
                    content = `
                        <p class="font-semibold mb-2">How the calculation works:</p>
                        <p>
                            The network uses a traditional static allocation model, dividing the total bandwidth equally among the devices.
                        </p>
                        <ul class="list-disc list-inside mt-2">
                            <li><span class="font-bold">Server:</span> Receives 33.3% of the total bandwidth.</li>
                            <li><span class="font-bold">Host 1 (h1):</span> Receives 33.3% of the total bandwidth.</li>
                            <li><span class="font-bold">Host 2 (h2):</span> Receives 33.3% of the total bandwidth.</li>
                        </ul>
                        <p class="mt-2">
                            This model provides a fair share for all devices but lacks the ability to prioritize critical applications or adapt to changing traffic demands.
                        </p>
                    `;
                    loadConfigBtn.textContent = 'Load Traditional Configuration';
                }
                explanationDiv.innerHTML = content;
            }

            function calculateBandwidth() {
                const totalBw = parseFloat(totalBandwidthInput.value);
                const isAIDriven = aiToggle.checked;

                if (isNaN(totalBw) || totalBw <= 0) {
                    alert('Please enter a valid positive number for bandwidth.');
                    return;
                }

                if (isAIDriven) {
                    serverBwEl.textContent = (totalBw * AI_ALLOCATION.server).toFixed(2);
                    h1BwEl.textContent = (totalBw * AI_ALLOCATION.h1).toFixed(2);
                    h2BwEl.textContent = (totalBw * AI_ALLOCATION.h2).toFixed(2);
                } else {
                    const allocatedBw = (totalBw * TRADITIONAL_ALLOCATION).toFixed(2);
                    serverBwEl.textContent = allocatedBw;
                    h1BwEl.textContent = allocatedBw;
                    h2BwEl.textContent = allocatedBw;
                }

                // Update topology link label
                const h1s1Link = links.find(link => link.from === 'h1' && link.to === 's1');
                if (h1s1Link) {
                    h1s1Link.label = `${totalBw} Mbps`;
                    drawTopology();
                }
            }
            
            calculateBtn.addEventListener('click', calculateBandwidth);
            totalBandwidthInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    calculateBandwidth();
                }
            });
            
            aiToggle.addEventListener('change', updateExplanation);
            
            loadConfigBtn.addEventListener('click', () => {
                const isAIDriven = aiToggle.checked;
                totalBandwidthInput.value = isAIDriven ? 1000 : 900;
                calculateBandwidth();
            });

            // --- INITIAL SETUP ON LOAD ---
            window.onload = function() {
                if (canvas) {
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;
                    initializeTopology();
                }
                updateExplanation(); // Set initial explanation text based on default toggle state
            };
            
            window.addEventListener('resize', () => {
                if (document.getElementById('topology').classList.contains('active')) {
                    const canvas = document.getElementById('networkCanvas');
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;
                    drawTopology();
                }
            });
        })();
    </script>
</body>
</html>
